---
layout: post
title: Building a Docker Image from your Rails Application
---

Wether you are running apps on your own infrastructure or deploying to the cloud, there are many [reasons](https://www.docker.com/why-docker) to containerize your Rails application. However, the template generated by `rails new` doesn’t help you there, as the generated code has to be adapted to run in Docker. You will need to do some modifications to the app and add a carefully designed Dockerfile, which is important for speeding up build times and reducing the image size. That's what this post is about.

This text will explain step by step the instructions that compose a Dockerfile for typical Rails app. A basic understanding of Docker concepts and Dockerfile syntax is required for understanding the content.

One very important decision, that will impact the way you build your image is how you want to handle the assets. Particularlly, you should answer these two questions:
1. When will the assets precompilation happen? Will it be done in development time, and pushed to the source code repository? Or will it take place later, during the deploy process?
2. How will these assets be served? By the same application server? Other server on the same infrastructures? Or will you use an external CDN?

There are no correct answers here, as this depends on many factors that are application or environment-specific. In our use case, which is described here, we assume a simple scenario where:
- We don't want developers to care about building assets for production. The CI script should handle it.
- In a small scale environment, the assets can be served by the same container that runs the application.

<!-- configs -->

### Configuration Data
Now let's get started. The first thing to be aware of when containerizing your application is that you should not have any configuration data in your docker image. This means that you will have to look at the source code searching for files that hold database connection settings, URLs for external services, and any other parameters that might change depending on the environment. Typical files to look are `config/database.yml`, `config/storage.yml`, and `config/initializers/*`. You should replace hard-coded values with environment variables. Here is what a typical `database.yml` would look like, using *postgresql* as an example:

```
default: &default
  adapter: adapter: <%= ENV["DB_ADAPTER"] || 'postgresql' %>
  encoding: unicode
  pool: <%= ENV.fetch("RAILS_MAX_THREADS", 20) %>
  database: <%= ENV["DB_DATABASE"] %>
  username: <%= ENV["DB_USERNAME"] %>
  password: <%= ENV["DB_PASSWORD"] %>
  host: <%= ENV["DB_HOST"] %>
  port: <%= ENV["DB_PORT"] || 5432 %>

development:
  <<: *default

test:
  <<: *default

staging:
  <<: *default

production:
  <<: *default
```

If you start your application using Docker Compose, it will automatically load environment variables from a file called `.env` in the working directory, if it finds one. If not using docker in your development environment, you might find it convenient to use the [dotenv](https://github.com/bkeepers/dotenv) gem. Your `.env` file should look like this:
```
RAILS_LOG_TO_STDOUT=true
RAILS_SERVE_STATIC_FILES=true
RAILS_ENV=production

DB_DATABASE=rails_docker_demo
DB_USERNAME=rails_docker_demo
DB_PASSWORD=my_pg_pass123
DB_HOST=db                    # hostname of your database server
DB_PORT=5432
```

Note the `RAILS_LOG_TO_STDOUT` variable. It is not a good practice to write data to the container's filesystem, so this setting is used to send the logs to standard output. The default-generated Rails configuration will test for this variable when running in staging or production environment. If you intend to run your development environment on Docker, you should copy this code from `config/environments/production.rb` to `config/environments/development.rb`:
```
if ENV["RAILS_LOG_TO_STDOUT"].present?
  logger           = ActiveSupport::Logger.new(STDOUT)
  logger.formatter = config.log_formatter
  config.logger    = ActiveSupport::TaggedLogging.new(logger)
end
```

### Preparing the Environment
Now that the configuration data is taken care of, let’s look at the steps necessary for building the image that will run the application. These are the commands that will go in the application's Dockerfile. Starting from a very skinny linux distribution, we need to install all the things necessary to precompile the assets and run the app. In summary, what needs to be done is:
1. Setup the environment
- Choose a base image to start from
- Install basic build tools
- Install *nodejs*, *yarn*, *bundler*
- Install database client
2. Install the application
- Install *ruby* dependencies
- Install *javascript* dependencies
- Copy application files
- Precompile the assets

Let's go over these, step by, step. We start from the official ruby Docker image:
```
FROM ruby:2.7.4-slim
```

Then, add basic build tools which will be required in subsequent steps:
```
RUN apt-get update && \
    apt-get install -y --no-install-recommends \
              ca-certificates \
              curl \
              git \
              openssh-client \
              build-essential \
              libc6 \
              gnupg \
              shared-mime-info && \
    rm -rf /var/lib/apt/lists/*
```

We will be needing *nodejs* to handle assets precompiling, *yarn* to install javascript dependencies, and *bundler* for the ruby gems:
```
RUN curl -sL https://deb.nodesource.com/setup_lts.x | bash - && \
    apt-get update && \
    apt-get install -y --no-install-recommends nodejs && \
    rm -rf /var/lib/apt/lists/*

RUN npm install --global yarn

RUN gem install bundler
```

Next step, database client. You will need to install the client library / headers. This part is highly dependable on the database you are using. Here is what you would need for *postgresql*:
```
RUN apt-get update && \
    apt-get install -y --no-install-recommends libpq-dev && \
    rm -rf /var/lib/apt/lists/*
```

### Install The Application

So far, we have covered environment setup. Now we will start installing the application itself. First, let's install the ruby dependencies:
```
COPY Gemfile .
COPY Gemfile.lock .
RUN bundle
```
You might be thinking: why not just copy all the application files and then run bundle install? 
Well, the docker build process executes a series of commands based on a context. The context, in this case, are the files that you include with the COPY command. If the context does not change between builds, docker will use a cached result instead of executing the command again. If we had copied the entire application in this step, whenever you changed any file, the build process would reinstall all the gems. Copying only the bundle-related files has the effect of invalidating the docker build cache only when the bundle changes.

Continuing with the setup, install javascript dependencies:
```
COPY package.json .
COPY yarn.lock .
RUN yarn
```

Then, we copy the application files:
```
RUN mkdir -p /app
WORKDIR /app
COPY . /app
```
There is one important thing to note here, tough. When docker runs the command `COPY . /app`, it will copy *all* files it finds in the application directory. If you are not careful, this might include log files (in case you are logging to the filesystem when developing), database files (if stored under /app), and other unnecessary stuff. Including unwanted files in your image can cause you two problems: it will increase the image size, and every time one of these file changes, it will trigger an unnecessary rebuild of the image

To solve this, you should have a `.dockerignore` file that tells docker which files you *do not* want in the resulting image. You can read about it [here](https://docs.docker.com/engine/reference/builder/#dockerignore-file), if you are not familiar, or grab the [example](https://github.com/CoolRequest/rails_docker_demo/blob/master/.dockerignore) from our rails_docker_demo repository.


Next step, the application's assets. Since we will be hosting the assets on the same container, we have to get them into the image:
```
RUN bundle exec rake assets:precompile DB_ADAPTER=nulldb NODE_ENV=development RAILS_ENV=staging SECRET_KEY_BASE=123
```
The `DB_ADAPTER=nulldb` variable is worth mentioning. When rails runs this rake task, it will boot the application in order to run the compiling. Depending on your environment, you might not have the environment varibles with database connection parameters at this moment, which would result in an error. So we use the [nulldb](https://github.com/nulldb/nulldb) adapter, database backend that translates database interactions into no-ops.

Finally, the EXPOSE command informs the TCP port the container will be responding on, and CMD provides a default command for running the server:
```
EXPOSE 3000
CMD ["bundle", "exec", "rails", "server", "-b", "0.0.0.0"]
```

### That's It
These are the steps necessary to make a Docker image from your Rails app. You can access the full Dockerfile in [this link](https://github.com/CoolRequest/rails_docker_demo/blob/master/Dockerfile).
This sample project also contains a `docker-compose.yml` file that starts the application and a containerized *postgresql* database that you can use to try it out.

---

<div class="message">
If you want to run your application on Docker but lack the necessary time or experience, feel free to contact us and we will be happy to give you a hand.
</div>
