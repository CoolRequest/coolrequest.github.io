---
layout: post
title: Building a Docker Image for your Rails Application - Part 1
---

Wether you are running apps on your own infrastructure or deploying to the cloud, there are many [reasons](https://www.docker.com/why-docker) to containerize your Rails application. However, the template generated by `rails new` doesn’t help you there, as the generated code has to be adapted to run in Docker. You will need to do some modifications to the app and add a carefully designed Dockerfile, which is important for speeding up build times and reducing the image size. That's what this post is about.

The text is divided in 3 parts. In this first post, we take a look at what you should change in your application code in order to make it suitable to run inside a docker container. Part 2 is about building a base image that contains the prerequisites needed for a typical Ruby on Rails app. Finally, on part 3, we show how to add the application files, create and run your container. A basic understanding of Docker concepts and Dockerfile syntax is required for understanding the content.

### Assumptions

One very important decision that will impact the way you build your image is how you want to handle the assets. Particularly, you should answer these two questions:

<div class="message">
1. When will the assets precompilation happen? Will it be done in development time, and pushed to the source code repository? Or will it take place later, during the deploy process?<br><br>
2. How will these assets be served? By the same application server? Other server on the same infrastructures? Or will you use an external CDN?
</div>

There are no correct answers here, as this depends on many factors that are application or environment-specific. In our use case, which is described here, we assume a simple scenario where:
- We don't want developers to care about building assets for production. The CI script should handle it.
- In a small scale environment, the assets can be served by the same container that runs the application.

<!-- configs -->

### Configuration Data
Now let's get started. The first thing to notice when containerizing your application is that you should not have any configuration data in your docker image. Instead, the configuration files should reference environment variables that are defined elsewhere, outside the image. This allows you to use the same image in different environments, just by setting the appropriate values for the variables.

To achieve this, you will have to look at the source code searching for files that hold database connection settings, URLs for external services, and any other parameters that might change depending on the environment. Typical files to look are `config/database.yml`, `config/storage.yml`, and `config/initializers/*`. You should replace hard-coded values with environment variables. Here is what an example `database.yml` that references environment variables, using *postgresql* as an example:

{% highlight yaml %}
default: &default
  adapter: <%= ENV["DB_ADAPTER"] || 'postgresql' %>
  encoding: unicode
  pool: <%= ENV.fetch("RAILS_MAX_THREADS", 10) %>
  database: <%= ENV["DB_DATABASE"] %>
  username: <%= ENV["DB_USERNAME"] %>
  password: <%= ENV["DB_PASSWORD"] %>
  host: <%= ENV["DB_HOST"] %>
  port: <%= ENV["DB_PORT"] || 5432 %>

development:
  <<: *default

test:
  <<: *default

staging:
  <<: *default

production:
  <<: *default
{% endhighlight %}

### Providing values for the environment variables

The values for the environment variables need to be provided when you run your container. If you start your application using Docker Compose, it will automatically load environment variables from a file called `.env` in the working directory, if it finds one. You can also supply additional .env files in your docker-compose.yml, if you like.

For development, you might find it convenient to use the [dotenv](https://github.com/bkeepers/dotenv) gem. It has these main benefits:
- It loads values from .env files into your environments independently of docker compose, allowing you use the same config files inside or outside a docker container.
- It allows you to have multiple .env files, and automatically load the ones corresponding to your environment
- It takes a 3-level hierarchical approach
  - `.env` - holds settings common to all environments
  - `.env.development` (and similarly, .env.staging / .env.production) - environment specific settings. overrides variables from `.env`
  - `.env.development.local` - optionally, if you want to have settings only on your local machine and not mess up your git history, you can use this file to set local values.

Here is an example configuration using multiple `.env` files:

{% highlight ini %}
# .env
RAILS_LOG_TO_STDOUT=true
RAILS_SERVE_STATIC_FILES=true
RAILS_ENV=production

# .env.development
DB_DATABASE=rails_docker_demo
DB_USERNAME=rails_docker_demo
DB_PASSWORD=my_pg_pass123
DB_HOST=localhost
DB_PORT=5432
{% endhighlight %}

### Should I commit or .gitignore my .env files?

Basically:
- don't commmit *.local
- commit the others
- but don't commit passwords (use secrets!)

### Rails Configs for docker

What about the RAILS_LOG_TO_STDOUT that appeared earlier?

<!-- 

- tirar a parte de copiar a configuracao relativa ao RAILS_LOG_TO_STDOUT
- só explicar por que a variável está ali
- ver se tem mais alguma config que seja relevante

-->

Note the `RAILS_LOG_TO_STDOUT` variable. It is not a good practice to write data to the container's filesystem, so this setting is used to send the logs to standard output. The default-generated Rails configuration will test for this variable when running in staging or production environment. If you intend to run your development environment on Docker, you should copy this code from `config/environments/production.rb` to `config/environments/development.rb`:

{% highlight ruby %}
if ENV["RAILS_LOG_TO_STDOUT"].present?
  logger           = ActiveSupport::Logger.new(STDOUT)
  logger.formatter = config.log_formatter
  config.logger    = ActiveSupport::TaggedLogging.new(logger)
end
{% endhighlight %}

### That's It
This is how you change your application...
In the next post...

---

<div class="message">
If you want to run your application on Docker but lack the necessary time or experience, feel free to contact us and we will be happy to give you a hand.
</div>
